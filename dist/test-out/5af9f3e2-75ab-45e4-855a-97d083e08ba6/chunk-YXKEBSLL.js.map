{"version":3,"sources":["node_modules/@capacitor-community/sqlite/dist/esm/definitions.js","node_modules/@capacitor-community/sqlite/dist/esm/index.js","src/app/services/sqlite.service.ts"],"sourcesContent":["//import { Capacitor } from '@capacitor/core';\n/**\n * SQLiteConnection Class\n */\nexport class SQLiteConnection {\n    constructor(sqlite) {\n        this.sqlite = sqlite;\n        this._connectionDict = new Map();\n    }\n    async initWebStore() {\n        try {\n            await this.sqlite.initWebStore();\n            return Promise.resolve();\n        }\n        catch (err) {\n            return Promise.reject(err);\n        }\n    }\n    async saveToStore(database) {\n        try {\n            await this.sqlite.saveToStore({ database });\n            return Promise.resolve();\n        }\n        catch (err) {\n            return Promise.reject(err);\n        }\n    }\n    async saveToLocalDisk(database) {\n        try {\n            await this.sqlite.saveToLocalDisk({ database });\n            return Promise.resolve();\n        }\n        catch (err) {\n            return Promise.reject(err);\n        }\n    }\n    async getFromLocalDiskToStore(overwrite) {\n        const mOverwrite = overwrite != null ? overwrite : true;\n        try {\n            await this.sqlite.getFromLocalDiskToStore({ overwrite: mOverwrite });\n            return Promise.resolve();\n        }\n        catch (err) {\n            return Promise.reject(err);\n        }\n    }\n    async echo(value) {\n        try {\n            const res = await this.sqlite.echo({ value });\n            return Promise.resolve(res);\n        }\n        catch (err) {\n            return Promise.reject(err);\n        }\n    }\n    async isSecretStored() {\n        try {\n            const res = await this.sqlite.isSecretStored();\n            return Promise.resolve(res);\n        }\n        catch (err) {\n            return Promise.reject(err);\n        }\n    }\n    async setEncryptionSecret(passphrase) {\n        try {\n            await this.sqlite.setEncryptionSecret({ passphrase: passphrase });\n            return Promise.resolve();\n        }\n        catch (err) {\n            return Promise.reject(err);\n        }\n    }\n    async changeEncryptionSecret(passphrase, oldpassphrase) {\n        try {\n            await this.sqlite.changeEncryptionSecret({\n                passphrase: passphrase,\n                oldpassphrase: oldpassphrase,\n            });\n            return Promise.resolve();\n        }\n        catch (err) {\n            return Promise.reject(err);\n        }\n    }\n    async clearEncryptionSecret() {\n        try {\n            await this.sqlite.clearEncryptionSecret();\n            return Promise.resolve();\n        }\n        catch (err) {\n            return Promise.reject(err);\n        }\n    }\n    async checkEncryptionSecret(passphrase) {\n        try {\n            const res = await this.sqlite.checkEncryptionSecret({\n                passphrase: passphrase,\n            });\n            return Promise.resolve(res);\n        }\n        catch (err) {\n            return Promise.reject(err);\n        }\n    }\n    async addUpgradeStatement(database, upgrade) {\n        try {\n            if (database.endsWith('.db'))\n                database = database.slice(0, -3);\n            await this.sqlite.addUpgradeStatement({\n                database,\n                upgrade,\n            });\n            return Promise.resolve();\n        }\n        catch (err) {\n            return Promise.reject(err);\n        }\n    }\n    async createConnection(database, encrypted, mode, version, readonly) {\n        try {\n            if (database.endsWith('.db'))\n                database = database.slice(0, -3);\n            await this.sqlite.createConnection({\n                database,\n                encrypted,\n                mode,\n                version,\n                readonly,\n            });\n            const conn = new SQLiteDBConnection(database, readonly, this.sqlite);\n            const connName = readonly ? `RO_${database}` : `RW_${database}`;\n            this._connectionDict.set(connName, conn);\n            /*\n            console.log(`*** in createConnection connectionDict: ***`)\n            this._connectionDict.forEach((connection, key) => {\n              console.log(`Key: ${key}, Value: ${connection}`);\n            });\n      */\n            return Promise.resolve(conn);\n        }\n        catch (err) {\n            return Promise.reject(err);\n        }\n    }\n    async closeConnection(database, readonly) {\n        try {\n            if (database.endsWith('.db'))\n                database = database.slice(0, -3);\n            await this.sqlite.closeConnection({ database, readonly });\n            const connName = readonly ? `RO_${database}` : `RW_${database}`;\n            this._connectionDict.delete(connName);\n            /*      console.log(`*** in closeConnection connectionDict: ***`)\n            this._connectionDict.forEach((connection, key) => {\n              console.log(`Key: ${key}, Value: ${connection}`);\n            });\n      */\n            return Promise.resolve();\n        }\n        catch (err) {\n            return Promise.reject(err);\n        }\n    }\n    async isConnection(database, readonly) {\n        const res = {};\n        if (database.endsWith('.db'))\n            database = database.slice(0, -3);\n        const connName = readonly ? `RO_${database}` : `RW_${database}`;\n        res.result = this._connectionDict.has(connName);\n        return Promise.resolve(res);\n    }\n    async retrieveConnection(database, readonly) {\n        if (database.endsWith('.db'))\n            database = database.slice(0, -3);\n        const connName = readonly ? `RO_${database}` : `RW_${database}`;\n        if (this._connectionDict.has(connName)) {\n            const conn = this._connectionDict.get(connName);\n            if (typeof conn != 'undefined')\n                return Promise.resolve(conn);\n            else {\n                return Promise.reject(`Connection ${database} is undefined`);\n            }\n        }\n        else {\n            return Promise.reject(`Connection ${database} does not exist`);\n        }\n    }\n    async getNCDatabasePath(path, database) {\n        try {\n            const databasePath = await this.sqlite.getNCDatabasePath({\n                path,\n                database,\n            });\n            return Promise.resolve(databasePath);\n        }\n        catch (err) {\n            return Promise.reject(err);\n        }\n    }\n    async createNCConnection(databasePath, version) {\n        try {\n            await this.sqlite.createNCConnection({\n                databasePath,\n                version,\n            });\n            const conn = new SQLiteDBConnection(databasePath, true, this.sqlite);\n            const connName = `RO_${databasePath})`;\n            this._connectionDict.set(connName, conn);\n            return Promise.resolve(conn);\n        }\n        catch (err) {\n            return Promise.reject(err);\n        }\n    }\n    async closeNCConnection(databasePath) {\n        try {\n            await this.sqlite.closeNCConnection({ databasePath });\n            const connName = `RO_${databasePath})`;\n            this._connectionDict.delete(connName);\n            return Promise.resolve();\n        }\n        catch (err) {\n            return Promise.reject(err);\n        }\n    }\n    async isNCConnection(databasePath) {\n        const res = {};\n        const connName = `RO_${databasePath})`;\n        res.result = this._connectionDict.has(connName);\n        return Promise.resolve(res);\n    }\n    async retrieveNCConnection(databasePath) {\n        if (this._connectionDict.has(databasePath)) {\n            const connName = `RO_${databasePath})`;\n            const conn = this._connectionDict.get(connName);\n            if (typeof conn != 'undefined')\n                return Promise.resolve(conn);\n            else {\n                return Promise.reject(`Connection ${databasePath} is undefined`);\n            }\n        }\n        else {\n            return Promise.reject(`Connection ${databasePath} does not exist`);\n        }\n    }\n    async isNCDatabase(databasePath) {\n        try {\n            const res = await this.sqlite.isNCDatabase({ databasePath });\n            return Promise.resolve(res);\n        }\n        catch (err) {\n            return Promise.reject(err);\n        }\n    }\n    async retrieveAllConnections() {\n        return this._connectionDict;\n    }\n    async closeAllConnections() {\n        const delDict = new Map();\n        try {\n            /*      console.log(`*** in closeAllConnections connectionDict: ***`)\n            this._connectionDict.forEach((connection, key) => {\n              console.log(`Key: ${key}, Value: ${connection}`);\n            });\n      */\n            for (const key of this._connectionDict.keys()) {\n                const database = key.substring(3);\n                const readonly = key.substring(0, 3) === 'RO_' ? true : false;\n                await this.sqlite.closeConnection({ database, readonly });\n                delDict.set(key, null);\n            }\n            for (const key of delDict.keys()) {\n                this._connectionDict.delete(key);\n            }\n            return Promise.resolve();\n        }\n        catch (err) {\n            return Promise.reject(err);\n        }\n    }\n    async checkConnectionsConsistency() {\n        try {\n            const keys = [...this._connectionDict.keys()];\n            const openModes = [];\n            const dbNames = [];\n            for (const key of keys) {\n                openModes.push(key.substring(0, 2));\n                dbNames.push(key.substring(3));\n            }\n            const res = await this.sqlite.checkConnectionsConsistency({\n                dbNames: dbNames,\n                openModes: openModes,\n            });\n            if (!res.result)\n                this._connectionDict = new Map();\n            return Promise.resolve(res);\n        }\n        catch (err) {\n            this._connectionDict = new Map();\n            return Promise.reject(err);\n        }\n    }\n    async importFromJson(jsonstring) {\n        try {\n            const ret = await this.sqlite.importFromJson({ jsonstring: jsonstring });\n            return Promise.resolve(ret);\n        }\n        catch (err) {\n            return Promise.reject(err);\n        }\n    }\n    async isJsonValid(jsonstring) {\n        try {\n            const ret = await this.sqlite.isJsonValid({ jsonstring: jsonstring });\n            return Promise.resolve(ret);\n        }\n        catch (err) {\n            return Promise.reject(err);\n        }\n    }\n    async copyFromAssets(overwrite) {\n        const mOverwrite = overwrite != null ? overwrite : true;\n        try {\n            await this.sqlite.copyFromAssets({ overwrite: mOverwrite });\n            return Promise.resolve();\n        }\n        catch (err) {\n            return Promise.reject(err);\n        }\n    }\n    async getFromHTTPRequest(url, overwrite) {\n        const mOverwrite = overwrite != null ? overwrite : true;\n        try {\n            await this.sqlite.getFromHTTPRequest({ url, overwrite: mOverwrite });\n            return Promise.resolve();\n        }\n        catch (err) {\n            return Promise.reject(err);\n        }\n    }\n    async isDatabaseEncrypted(database) {\n        if (database.endsWith('.db'))\n            database = database.slice(0, -3);\n        try {\n            const res = await this.sqlite.isDatabaseEncrypted({ database: database });\n            return Promise.resolve(res);\n        }\n        catch (err) {\n            return Promise.reject(err);\n        }\n    }\n    async isInConfigEncryption() {\n        try {\n            const res = await this.sqlite.isInConfigEncryption();\n            return Promise.resolve(res);\n        }\n        catch (err) {\n            return Promise.reject(err);\n        }\n    }\n    async isInConfigBiometricAuth() {\n        try {\n            const res = await this.sqlite.isInConfigBiometricAuth();\n            return Promise.resolve(res);\n        }\n        catch (err) {\n            return Promise.reject(err);\n        }\n    }\n    async isDatabase(database) {\n        if (database.endsWith('.db'))\n            database = database.slice(0, -3);\n        try {\n            const res = await this.sqlite.isDatabase({ database: database });\n            return Promise.resolve(res);\n        }\n        catch (err) {\n            return Promise.reject(err);\n        }\n    }\n    async getDatabaseList() {\n        try {\n            const res = await this.sqlite.getDatabaseList();\n            const values = res.values;\n            values.sort();\n            const ret = { values: values };\n            return Promise.resolve(ret);\n        }\n        catch (err) {\n            return Promise.reject(err);\n        }\n    }\n    async getMigratableDbList(folderPath) {\n        const path = folderPath ? folderPath : 'default';\n        try {\n            const res = await this.sqlite.getMigratableDbList({\n                folderPath: path,\n            });\n            return Promise.resolve(res);\n        }\n        catch (err) {\n            return Promise.reject(err);\n        }\n    }\n    async addSQLiteSuffix(folderPath, dbNameList) {\n        const path = folderPath ? folderPath : 'default';\n        const dbList = dbNameList ? dbNameList : [];\n        try {\n            const res = await this.sqlite.addSQLiteSuffix({\n                folderPath: path,\n                dbNameList: dbList,\n            });\n            return Promise.resolve(res);\n        }\n        catch (err) {\n            return Promise.reject(err);\n        }\n    }\n    async deleteOldDatabases(folderPath, dbNameList) {\n        const path = folderPath ? folderPath : 'default';\n        const dbList = dbNameList ? dbNameList : [];\n        try {\n            const res = await this.sqlite.deleteOldDatabases({\n                folderPath: path,\n                dbNameList: dbList,\n            });\n            return Promise.resolve(res);\n        }\n        catch (err) {\n            return Promise.reject(err);\n        }\n    }\n    async moveDatabasesAndAddSuffix(folderPath, dbNameList) {\n        const path = folderPath ? folderPath : 'default';\n        const dbList = dbNameList ? dbNameList : [];\n        return this.sqlite.moveDatabasesAndAddSuffix({\n            folderPath: path,\n            dbNameList: dbList,\n        });\n    }\n}\n/**\n * SQLiteDBConnection Class\n */\nexport class SQLiteDBConnection {\n    constructor(dbName, readonly, sqlite) {\n        this.dbName = dbName;\n        this.readonly = readonly;\n        this.sqlite = sqlite;\n    }\n    getConnectionDBName() {\n        return this.dbName;\n    }\n    getConnectionReadOnly() {\n        return this.readonly;\n    }\n    async open() {\n        try {\n            await this.sqlite.open({\n                database: this.dbName,\n                readonly: this.readonly,\n            });\n            return Promise.resolve();\n        }\n        catch (err) {\n            return Promise.reject(err);\n        }\n    }\n    async close() {\n        try {\n            await this.sqlite.close({\n                database: this.dbName,\n                readonly: this.readonly,\n            });\n            return Promise.resolve();\n        }\n        catch (err) {\n            return Promise.reject(err);\n        }\n    }\n    async beginTransaction() {\n        try {\n            const changes = await this.sqlite.beginTransaction({\n                database: this.dbName,\n            });\n            return Promise.resolve(changes);\n        }\n        catch (err) {\n            return Promise.reject(err);\n        }\n    }\n    async commitTransaction() {\n        try {\n            const changes = await this.sqlite.commitTransaction({\n                database: this.dbName,\n            });\n            return Promise.resolve(changes);\n        }\n        catch (err) {\n            return Promise.reject(err);\n        }\n    }\n    async rollbackTransaction() {\n        try {\n            const changes = await this.sqlite.rollbackTransaction({\n                database: this.dbName,\n            });\n            return Promise.resolve(changes);\n        }\n        catch (err) {\n            return Promise.reject(err);\n        }\n    }\n    async isTransactionActive() {\n        try {\n            const result = await this.sqlite.isTransactionActive({\n                database: this.dbName,\n            });\n            return Promise.resolve(result);\n        }\n        catch (err) {\n            return Promise.reject(err);\n        }\n    }\n    async loadExtension(path) {\n        try {\n            await this.sqlite.loadExtension({\n                database: this.dbName,\n                path: path,\n                readonly: this.readonly,\n            });\n            return Promise.resolve();\n        }\n        catch (err) {\n            return Promise.reject(err);\n        }\n    }\n    async enableLoadExtension(toggle) {\n        try {\n            await this.sqlite.enableLoadExtension({\n                database: this.dbName,\n                toggle: toggle,\n                readonly: this.readonly,\n            });\n            return Promise.resolve();\n        }\n        catch (err) {\n            return Promise.reject(err);\n        }\n    }\n    async getUrl() {\n        try {\n            const res = await this.sqlite.getUrl({\n                database: this.dbName,\n                readonly: this.readonly,\n            });\n            return Promise.resolve(res);\n        }\n        catch (err) {\n            return Promise.reject(err);\n        }\n    }\n    async getVersion() {\n        try {\n            const version = await this.sqlite.getVersion({\n                database: this.dbName,\n                readonly: this.readonly,\n            });\n            return Promise.resolve(version);\n        }\n        catch (err) {\n            return Promise.reject(err);\n        }\n    }\n    async getTableList() {\n        try {\n            const res = await this.sqlite.getTableList({\n                database: this.dbName,\n                readonly: this.readonly,\n            });\n            return Promise.resolve(res);\n        }\n        catch (err) {\n            return Promise.reject(err);\n        }\n    }\n    async execute(statements, transaction = true, isSQL92 = true) {\n        try {\n            if (!this.readonly) {\n                const res = await this.sqlite.execute({\n                    database: this.dbName,\n                    statements: statements,\n                    transaction: transaction,\n                    readonly: false,\n                    isSQL92: isSQL92,\n                });\n                return Promise.resolve(res);\n            }\n            else {\n                return Promise.reject('not allowed in read-only mode');\n            }\n        }\n        catch (err) {\n            return Promise.reject(err);\n        }\n    }\n    async query(statement, values, isSQL92 = true) {\n        let res;\n        try {\n            if (values && values.length > 0) {\n                res = await this.sqlite.query({\n                    database: this.dbName,\n                    statement: statement,\n                    values: values,\n                    readonly: this.readonly,\n                    isSQL92: true,\n                });\n            }\n            else {\n                res = await this.sqlite.query({\n                    database: this.dbName,\n                    statement: statement,\n                    values: [],\n                    readonly: this.readonly,\n                    isSQL92: isSQL92,\n                });\n            }\n            // reorder rows for ios\n            res = await this.reorderRows(res);\n            return Promise.resolve(res);\n        }\n        catch (err) {\n            return Promise.reject(err);\n        }\n    }\n    async run(statement, values, transaction = true, returnMode = 'no', isSQL92 = true) {\n        let res;\n        try {\n            if (!this.readonly) {\n                if (values && values.length > 0) {\n                    res = await this.sqlite.run({\n                        database: this.dbName,\n                        statement: statement,\n                        values: values,\n                        transaction: transaction,\n                        readonly: false,\n                        returnMode: returnMode,\n                        isSQL92: true,\n                    });\n                }\n                else {\n                    res = await this.sqlite.run({\n                        database: this.dbName,\n                        statement: statement,\n                        values: [],\n                        transaction: transaction,\n                        readonly: false,\n                        returnMode: returnMode,\n                        isSQL92: isSQL92,\n                    });\n                }\n                // reorder rows for ios\n                res.changes = await this.reorderRows(res.changes);\n                return Promise.resolve(res);\n            }\n            else {\n                return Promise.reject('not allowed in read-only mode');\n            }\n        }\n        catch (err) {\n            return Promise.reject(err);\n        }\n    }\n    async executeSet(set, transaction = true, returnMode = 'no', isSQL92 = true) {\n        let res;\n        try {\n            if (!this.readonly) {\n                res = await this.sqlite.executeSet({\n                    database: this.dbName,\n                    set: set,\n                    transaction: transaction,\n                    readonly: false,\n                    returnMode: returnMode,\n                    isSQL92: isSQL92,\n                });\n                //      }\n                // reorder rows for ios\n                res.changes = await this.reorderRows(res.changes);\n                return Promise.resolve(res);\n            }\n            else {\n                return Promise.reject('not allowed in read-only mode');\n            }\n        }\n        catch (err) {\n            return Promise.reject(err);\n        }\n    }\n    async isExists() {\n        try {\n            const res = await this.sqlite.isDBExists({\n                database: this.dbName,\n                readonly: this.readonly,\n            });\n            return Promise.resolve(res);\n        }\n        catch (err) {\n            return Promise.reject(err);\n        }\n    }\n    async isTable(table) {\n        try {\n            const res = await this.sqlite.isTableExists({\n                database: this.dbName,\n                table: table,\n                readonly: this.readonly,\n            });\n            return Promise.resolve(res);\n        }\n        catch (err) {\n            return Promise.reject(err);\n        }\n    }\n    async isDBOpen() {\n        try {\n            const res = await this.sqlite.isDBOpen({\n                database: this.dbName,\n                readonly: this.readonly,\n            });\n            return Promise.resolve(res);\n        }\n        catch (err) {\n            return Promise.reject(err);\n        }\n    }\n    async delete() {\n        try {\n            if (!this.readonly) {\n                await this.sqlite.deleteDatabase({\n                    database: this.dbName,\n                    readonly: false,\n                });\n                return Promise.resolve();\n            }\n            else {\n                return Promise.reject('not allowed in read-only mode');\n            }\n        }\n        catch (err) {\n            return Promise.reject(err);\n        }\n    }\n    async createSyncTable() {\n        try {\n            if (!this.readonly) {\n                const res = await this.sqlite.createSyncTable({\n                    database: this.dbName,\n                    readonly: false,\n                });\n                return Promise.resolve(res);\n            }\n            else {\n                return Promise.reject('not allowed in read-only mode');\n            }\n        }\n        catch (err) {\n            return Promise.reject(err);\n        }\n    }\n    async setSyncDate(syncdate) {\n        try {\n            if (!this.readonly) {\n                await this.sqlite.setSyncDate({\n                    database: this.dbName,\n                    syncdate: syncdate,\n                    readonly: false,\n                });\n                return Promise.resolve();\n            }\n            else {\n                return Promise.reject('not allowed in read-only mode');\n            }\n        }\n        catch (err) {\n            return Promise.reject(err);\n        }\n    }\n    async getSyncDate() {\n        try {\n            const res = await this.sqlite.getSyncDate({\n                database: this.dbName,\n                readonly: this.readonly,\n            });\n            let retDate = '';\n            if (res.syncDate > 0)\n                retDate = new Date(res.syncDate * 1000).toISOString();\n            return Promise.resolve(retDate);\n        }\n        catch (err) {\n            return Promise.reject(err);\n        }\n    }\n    async exportToJson(mode, encrypted = false) {\n        try {\n            const res = await this.sqlite.exportToJson({\n                database: this.dbName,\n                jsonexportmode: mode,\n                readonly: this.readonly,\n                encrypted: encrypted,\n            });\n            return Promise.resolve(res);\n        }\n        catch (err) {\n            return Promise.reject(err);\n        }\n    }\n    async deleteExportedRows() {\n        try {\n            if (!this.readonly) {\n                await this.sqlite.deleteExportedRows({\n                    database: this.dbName,\n                    readonly: false,\n                });\n                return Promise.resolve();\n            }\n            else {\n                return Promise.reject('not allowed in read-only mode');\n            }\n        }\n        catch (err) {\n            return Promise.reject(err);\n        }\n    }\n    async executeTransaction(txn, isSQL92 = true) {\n        let changes = 0;\n        let isActive = false;\n        if (!this.readonly) {\n            await this.sqlite.beginTransaction({\n                database: this.dbName,\n            });\n            isActive = await this.sqlite.isTransactionActive({\n                database: this.dbName,\n            });\n            if (!isActive) {\n                return Promise.reject('After Begin Transaction, no transaction active');\n            }\n            try {\n                for (const task of txn) {\n                    if (typeof task !== 'object' || !('statement' in task)) {\n                        throw new Error('Error a task.statement must be provided');\n                    }\n                    if ('values' in task && task.values && task.values.length > 0) {\n                        const retMode = task.statement.toUpperCase().includes('RETURNING') ? 'all' : 'no';\n                        const ret = await this.sqlite.run({\n                            database: this.dbName,\n                            statement: task.statement,\n                            values: task.values,\n                            transaction: false,\n                            readonly: false,\n                            returnMode: retMode,\n                            isSQL92: isSQL92,\n                        });\n                        if (ret.changes.changes < 0) {\n                            throw new Error('Error in transaction method run ');\n                        }\n                        changes += ret.changes.changes;\n                    }\n                    else {\n                        const ret = await this.sqlite.execute({\n                            database: this.dbName,\n                            statements: task.statement,\n                            transaction: false,\n                            readonly: false,\n                        });\n                        if (ret.changes.changes < 0) {\n                            throw new Error('Error in transaction method execute ');\n                        }\n                        changes += ret.changes.changes;\n                    }\n                }\n                // commit\n                const retC = await this.sqlite.commitTransaction({\n                    database: this.dbName,\n                });\n                changes += retC.changes.changes;\n                const retChanges = { changes: { changes: changes } };\n                return Promise.resolve(retChanges);\n            }\n            catch (err) {\n                // rollback\n                const msg = err.message ? err.message : err;\n                await this.sqlite.rollbackTransaction({\n                    database: this.dbName,\n                });\n                return Promise.reject(msg);\n            }\n        }\n        else {\n            return Promise.reject('not allowed in read-only mode');\n        }\n    }\n    async reorderRows(res) {\n        const retRes = res;\n        if (res?.values && typeof res.values[0] === 'object') {\n            if (Object.keys(res.values[0]).includes('ios_columns')) {\n                const columnList = res.values[0]['ios_columns'];\n                const iosRes = [];\n                for (let i = 1; i < res.values.length; i++) {\n                    const rowJson = res.values[i];\n                    const resRowJson = {};\n                    for (const item of columnList) {\n                        resRowJson[item] = rowJson[item];\n                    }\n                    iosRes.push(resRowJson);\n                }\n                retRes['values'] = iosRes;\n            }\n        }\n        return Promise.resolve(retRes);\n    }\n}\n","import { registerPlugin } from '@capacitor/core';\nconst CapacitorSQLite = registerPlugin('CapacitorSQLite', {\n    web: () => import('./web').then((m) => new m.CapacitorSQLiteWeb()),\n    electron: () => window.CapacitorCustomPlatform.plugins.CapacitorSQLite,\n});\nexport { CapacitorSQLite };\nexport * from './definitions';\n","import { Injectable } from '@angular/core';\r\nimport { Capacitor } from '@capacitor/core';\r\nimport {\r\n  CapacitorSQLite,\r\n  SQLiteDBConnection,\r\n} from '@capacitor-community/sqlite';\r\n\r\n/**\r\n * Servicio SQLite compatible con distintas versiones de @capacitor-community/sqlite.\r\n * - Evita removeAllConnections (no existe en algunas versiones)\r\n * - Soporta createConnection con firma vieja (params sueltos) o nueva (objeto)\r\n */\r\n@Injectable({ providedIn: 'root' })\r\nexport class SqliteService {\r\n  private db: SQLiteDBConnection | null = null;\r\n  // lo tratamos como any para tolerar diferencias de API entre versiones\r\n  private sqlite: any = CapacitorSQLite as any;\r\n\r\n  get isNative(): boolean {\r\n    const p = Capacitor.getPlatform();\r\n    return p === 'android' || p === 'ios';\r\n  }\r\n\r\n  /** Llama esto al iniciar la app (ej: en app.component.ts o al entrar a Home protegida) */\r\n  async init(): Promise<void> {\r\n    if (!this.isNative) {\r\n      // En web puedes usar Ionic Storage / IndexedDB; SQLite nativo no aplica\r\n      return;\r\n    }\r\n\r\n    // 1) Chequeo de consistencia (algunas versiones no requieren args)\r\n    try {\r\n      if (this.sqlite?.checkConnectionsConsistency) {\r\n        if (this.sqlite.checkConnectionsConsistency.length === 0) {\r\n          await this.sqlite.checkConnectionsConsistency();\r\n        } else {\r\n          await this.sqlite.checkConnectionsConsistency({\r\n            dbNames: ['notasdb'],\r\n            openModes: ['no-encryption'],\r\n          });\r\n        }\r\n      }\r\n    } catch {\r\n      // ignoramos diferencias de implementación\r\n    }\r\n\r\n    // 2) Cerrar conexiones abiertas (si existe el método)\r\n    try {\r\n      if (this.sqlite?.closeAllConnections) {\r\n        await this.sqlite.closeAllConnections();\r\n      }\r\n    } catch {\r\n      // en versiones sin closeAllConnections no pasa nada\r\n    }\r\n\r\n    // 3) Crear conexión (firma vieja o nueva)\r\n    if (this.sqlite?.createConnection) {\r\n      if (this.usesOldCreateSignature()) {\r\n        // Firma vieja (nombre, encrypted, mode, version, readonly)\r\n        this.db = await this.sqlite.createConnection(\r\n          'notasdb',\r\n          false,\r\n          'no-encryption',\r\n          1,\r\n          false\r\n        );\r\n      } else {\r\n        // Firma nueva (objeto config)\r\n        this.db = await this.sqlite.createConnection({\r\n          database: 'notasdb',\r\n          version: 1,\r\n          encrypted: false,\r\n          mode: 'no-encryption',\r\n          readonly: false,\r\n        });\r\n      }\r\n    } else {\r\n      throw new Error('CapacitorSQLite.createConnection no está disponible');\r\n    }\r\n\r\n    // 4) Abrir DB y crear tabla\r\n    await this.db!.open();\r\n    await this.db!.execute(`\r\n      CREATE TABLE IF NOT EXISTS notes(\r\n        id INTEGER PRIMARY KEY NOT NULL,\r\n        titulo TEXT NOT NULL,\r\n        descripcion TEXT,\r\n        color TEXT,\r\n        createdAt TEXT,\r\n        updatedAt TEXT,\r\n        completada INTEGER DEFAULT 0\r\n      );\r\n    `);\r\n  }\r\n\r\n  /** Inserta una nota */\r\n  async create(note: {\r\n    id: number;\r\n    titulo: string;\r\n    descripcion?: string;\r\n    color?: string;\r\n    createdAt: string;\r\n    updatedAt: string;\r\n    completada?: boolean;\r\n  }): Promise<number> {\r\n    this.assertDB();\r\n    const res = await this.db!.run(\r\n      `INSERT INTO notes (id, titulo, descripcion, color, createdAt, updatedAt, completada)\r\n       VALUES (?, ?, ?, ?, ?, ?, ?)`,\r\n      [\r\n        note.id,\r\n        note.titulo,\r\n        note.descripcion ?? '',\r\n        note.color ?? 'gray',\r\n        note.createdAt,\r\n        note.updatedAt,\r\n        note.completada ? 1 : 0,\r\n      ]\r\n    );\r\n    return this.extractChanges(res);\r\n  }\r\n\r\n  /** Actualiza una nota */\r\n  async update(note: {\r\n    id: number;\r\n    titulo: string;\r\n    descripcion?: string;\r\n    color?: string;\r\n    updatedAt: string;\r\n    completada?: boolean;\r\n  }): Promise<number> {\r\n    this.assertDB();\r\n    const res = await this.db!.run(\r\n      `UPDATE notes\r\n         SET titulo=?, descripcion=?, color=?, updatedAt=?, completada=?\r\n       WHERE id=?`,\r\n      [\r\n        note.titulo,\r\n        note.descripcion ?? '',\r\n        note.color ?? 'gray',\r\n        note.updatedAt,\r\n        note.completada ? 1 : 0,\r\n        note.id,\r\n      ]\r\n    );\r\n    return this.extractChanges(res);\r\n  }\r\n\r\n  /** Elimina por id */\r\n  async delete(id: number): Promise<number> {\r\n    this.assertDB();\r\n    const res = await this.db!.run(`DELETE FROM notes WHERE id=?`, [id]);\r\n    return this.extractChanges(res);\r\n  }\r\n\r\n  /** Lista todas las notas (orden por updatedAt desc) */\r\n  async list(): Promise<any[]> {\r\n    this.assertDB();\r\n    const res = await this.db!.query(\r\n      `SELECT * FROM notes ORDER BY datetime(updatedAt) DESC`\r\n    );\r\n    return res.values ?? [];\r\n  }\r\n\r\n  /** Obtiene una nota por id */\r\n  async get(id: number): Promise<any | null> {\r\n    this.assertDB();\r\n    const res = await this.db!.query(`SELECT * FROM notes WHERE id=?`, [id]);\r\n    return (res.values ?? [])[0] ?? null;\r\n  }\r\n\r\n  /** Cierra conexión (opcional) */\r\n  async close(): Promise<void> {\r\n    if (!this.db) return;\r\n    try {\r\n      await this.db.close();\r\n    } catch {}\r\n    this.db = null;\r\n  }\r\n\r\n  // ----------------- helpers privados -----------------\r\n\r\n  /** Detecta si la firma de createConnection es la antigua (5 params) */\r\n  private usesOldCreateSignature(): boolean {\r\n    try {\r\n      // Heurística: en versiones antiguas length === 5\r\n      return typeof this.sqlite.createConnection === 'function'\r\n        && this.sqlite.createConnection.length >= 5;\r\n    } catch {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  private assertDB(): void {\r\n    if (!this.db) {\r\n      throw new Error('SQLite DB no inicializada. Llama primero a init()');\r\n    }\r\n  }\r\n\r\n  /** Normaliza la respuesta de .run() entre versiones */\r\n  private extractChanges(res: any): number {\r\n    // Algunas versiones retornan { changes: { changes: n } }, otras { changes: n }\r\n    if (!res) return 0;\r\n    if (typeof res.changes === 'number') return res.changes;\r\n    if (res.changes && typeof res.changes.changes === 'number')\r\n      return res.changes.changes;\r\n    return 0;\r\n  }\r\n}\r\n"],"mappings":"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","names":["SqliteService"],"x_google_ignoreList":[0,1]}