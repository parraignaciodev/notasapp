{"version":3,"sources":["node_modules/@ionic/core/dist/esm/validity-B8oWougr.js"],"sourcesContent":["/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\nimport { w as win } from './index-ZjP4CjeZ.js';\nimport { r as raf } from './helpers-DEn3pfjm.js';\n\n/**\n * A utility to calculate the size of an outline notch\n * width relative to the content passed. This is used in\n * components such as `ion-select` with `fill=\"outline\"`\n * where we need to pass slotted HTML content. This is not\n * needed when rendering plaintext content because we can\n * render the plaintext again hidden with `opacity: 0` inside\n * of the notch. As a result we can rely on the intrinsic size\n * of the element to correctly compute the notch width. We\n * cannot do this with slotted content because we cannot project\n * it into 2 places at once.\n *\n * @internal\n * @param el: The host element\n * @param getNotchSpacerEl: A function that returns a reference to the notch spacer element inside of the component template.\n * @param getLabelSlot: A function that returns a reference to the slotted content.\n */\nconst createNotchController = (el, getNotchSpacerEl, getLabelSlot) => {\n    let notchVisibilityIO;\n    const needsExplicitNotchWidth = () => {\n        const notchSpacerEl = getNotchSpacerEl();\n        if (\n        /**\n         * If the notch is not being used\n         * then we do not need to set the notch width.\n         */\n        notchSpacerEl === undefined ||\n            /**\n             * If either the label property is being\n             * used or the label slot is not defined,\n             * then we do not need to estimate the notch width.\n             */\n            el.label !== undefined ||\n            getLabelSlot() === null) {\n            return false;\n        }\n        return true;\n    };\n    const calculateNotchWidth = () => {\n        if (needsExplicitNotchWidth()) {\n            /**\n             * Run this the frame after\n             * the browser has re-painted the host element.\n             * Otherwise, the label element may have a width\n             * of 0 and the IntersectionObserver will be used.\n             */\n            raf(() => {\n                setNotchWidth();\n            });\n        }\n    };\n    /**\n     * When using a label prop we can render\n     * the label value inside of the notch and\n     * let the browser calculate the size of the notch.\n     * However, we cannot render the label slot in multiple\n     * places so we need to manually calculate the notch dimension\n     * based on the size of the slotted content.\n     *\n     * This function should only be used to set the notch width\n     * on slotted label content. The notch width for label prop\n     * content is automatically calculated based on the\n     * intrinsic size of the label text.\n     */\n    const setNotchWidth = () => {\n        const notchSpacerEl = getNotchSpacerEl();\n        if (notchSpacerEl === undefined) {\n            return;\n        }\n        if (!needsExplicitNotchWidth()) {\n            notchSpacerEl.style.removeProperty('width');\n            return;\n        }\n        const width = getLabelSlot().scrollWidth;\n        if (\n        /**\n         * If the computed width of the label is 0\n         * and notchSpacerEl's offsetParent is null\n         * then that means the element is hidden.\n         * As a result, we need to wait for the element\n         * to become visible before setting the notch width.\n         *\n         * We do not check el.offsetParent because\n         * that can be null if the host element has\n         * position: fixed applied to it.\n         * notchSpacerEl does not have position: fixed.\n         */\n        width === 0 &&\n            notchSpacerEl.offsetParent === null &&\n            win !== undefined &&\n            'IntersectionObserver' in win) {\n            /**\n             * If there is an IO already attached\n             * then that will update the notch\n             * once the element becomes visible.\n             * As a result, there is no need to create\n             * another one.\n             */\n            if (notchVisibilityIO !== undefined) {\n                return;\n            }\n            const io = (notchVisibilityIO = new IntersectionObserver((ev) => {\n                /**\n                 * If the element is visible then we\n                 * can try setting the notch width again.\n                 */\n                if (ev[0].intersectionRatio === 1) {\n                    setNotchWidth();\n                    io.disconnect();\n                    notchVisibilityIO = undefined;\n                }\n            }, \n            /**\n             * Set the root to be the host element\n             * This causes the IO callback\n             * to be fired in WebKit as soon as the element\n             * is visible. If we used the default root value\n             * then WebKit would only fire the IO callback\n             * after any animations (such as a modal transition)\n             * finished, and there would potentially be a flicker.\n             */\n            { threshold: 0.01, root: el }));\n            io.observe(notchSpacerEl);\n            return;\n        }\n        /**\n         * If the element is visible then we can set the notch width.\n         * The notch is only visible when the label is scaled,\n         * which is why we multiply the width by 0.75 as this is\n         * the same amount the label element is scaled by in the host CSS.\n         * (See $form-control-label-stacked-scale in ionic.globals.scss).\n         */\n        notchSpacerEl.style.setProperty('width', `${width * 0.75}px`);\n    };\n    const destroy = () => {\n        if (notchVisibilityIO) {\n            notchVisibilityIO.disconnect();\n            notchVisibilityIO = undefined;\n        }\n    };\n    return {\n        calculateNotchWidth,\n        destroy,\n    };\n};\n\n/**\n * Checks if the form element is in an invalid state based on\n * Ionic validation classes.\n *\n * @param el The form element to check.\n * @returns `true` if the element is invalid, `false` otherwise.\n */\nconst checkInvalidState = (el) => {\n    const hasIonTouched = el.classList.contains('ion-touched');\n    const hasIonInvalid = el.classList.contains('ion-invalid');\n    return hasIonTouched && hasIonInvalid;\n};\n\nexport { checkInvalidState as a, createNotchController as c };\n"],"mappings":";;;;;;;;;;;;;AAAA,IAuBM,uBAwIA;AA/JN;AAAA;AAAA;AAGA;AACA;AAmBA,IAAM,wBAAwB,CAAC,IAAI,kBAAkB,iBAAiB;AAClE,UAAI;AACJ,YAAM,0BAA0B,MAAM;AAClC,cAAM,gBAAgB,iBAAiB;AACvC;AAAA;AAAA;AAAA;AAAA;AAAA,UAKA,kBAAkB;AAAA;AAAA;AAAA;AAAA;AAAA,UAMd,GAAG,UAAU,UACb,aAAa,MAAM;AAAA,UAAM;AACzB,iBAAO;AAAA,QACX;AACA,eAAO;AAAA,MACX;AACA,YAAM,sBAAsB,MAAM;AAC9B,YAAI,wBAAwB,GAAG;AAO3B,cAAI,MAAM;AACN,0BAAc;AAAA,UAClB,CAAC;AAAA,QACL;AAAA,MACJ;AAcA,YAAM,gBAAgB,MAAM;AACxB,cAAM,gBAAgB,iBAAiB;AACvC,YAAI,kBAAkB,QAAW;AAC7B;AAAA,QACJ;AACA,YAAI,CAAC,wBAAwB,GAAG;AAC5B,wBAAc,MAAM,eAAe,OAAO;AAC1C;AAAA,QACJ;AACA,cAAM,QAAQ,aAAa,EAAE;AAC7B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,UAaA,UAAU,KACN,cAAc,iBAAiB,QAC/B,QAAQ,UACR,0BAA0B;AAAA,UAAK;AAQ/B,cAAI,sBAAsB,QAAW;AACjC;AAAA,UACJ;AACA,gBAAM,KAAM,oBAAoB,IAAI;AAAA,YAAqB,CAAC,OAAO;AAK7D,kBAAI,GAAG,CAAC,EAAE,sBAAsB,GAAG;AAC/B,8BAAc;AACd,mBAAG,WAAW;AACd,oCAAoB;AAAA,cACxB;AAAA,YACJ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,YAUA,EAAE,WAAW,MAAM,MAAM,GAAG;AAAA,UAAC;AAC7B,aAAG,QAAQ,aAAa;AACxB;AAAA,QACJ;AAQA,sBAAc,MAAM,YAAY,SAAS,GAAG,QAAQ,IAAI,IAAI;AAAA,MAChE;AACA,YAAM,UAAU,MAAM;AAClB,YAAI,mBAAmB;AACnB,4BAAkB,WAAW;AAC7B,8BAAoB;AAAA,QACxB;AAAA,MACJ;AACA,aAAO;AAAA,QACH;AAAA,QACA;AAAA,MACJ;AAAA,IACJ;AASA,IAAM,oBAAoB,CAAC,OAAO;AAC9B,YAAM,gBAAgB,GAAG,UAAU,SAAS,aAAa;AACzD,YAAM,gBAAgB,GAAG,UAAU,SAAS,aAAa;AACzD,aAAO,iBAAiB;AAAA,IAC5B;AAAA;AAAA;","names":[],"x_google_ignoreList":[0]}