{"version":3,"sources":["node_modules/@ionic/core/dist/esm/hardware-back-button-CPLxO-Ev.js"],"sourcesContent":["/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\nimport { w as win } from './index-ZjP4CjeZ.js';\nimport { e as config, j as printIonError } from './index-C8IsBmNU.js';\n\n/**\n * CloseWatcher is a newer API that lets\n * use detect the hardware back button event\n * in a web browser: https://caniuse.com/?search=closewatcher\n * However, not every browser supports it yet.\n *\n * This needs to be a function so that we can\n * check the config once it has been set.\n * Otherwise, this code would be evaluated the\n * moment this file is evaluated which could be\n * before the config is set.\n */\nconst shouldUseCloseWatcher = () => config.get('experimentalCloseWatcher', false) && win !== undefined && 'CloseWatcher' in win;\n/**\n * When hardwareBackButton: false in config,\n * we need to make sure we also block the default\n * webview behavior. If we don't then it will be\n * possible for users to navigate backward while\n * an overlay is still open. Additionally, it will\n * give the appearance that the hardwareBackButton\n * config is not working as the page transition\n * will still happen.\n */\nconst blockHardwareBackButton = () => {\n    document.addEventListener('backbutton', () => { }); // eslint-disable-line\n};\nconst startHardwareBackButton = () => {\n    const doc = document;\n    let busy = false;\n    const backButtonCallback = () => {\n        if (busy) {\n            return;\n        }\n        let index = 0;\n        let handlers = [];\n        const ev = new CustomEvent('ionBackButton', {\n            bubbles: false,\n            detail: {\n                register(priority, handler) {\n                    handlers.push({ priority, handler, id: index++ });\n                },\n            },\n        });\n        doc.dispatchEvent(ev);\n        const executeAction = async (handlerRegister) => {\n            try {\n                if (handlerRegister === null || handlerRegister === void 0 ? void 0 : handlerRegister.handler) {\n                    const result = handlerRegister.handler(processHandlers);\n                    if (result != null) {\n                        await result;\n                    }\n                }\n            }\n            catch (e) {\n                printIonError('[ion-app] - Exception in startHardwareBackButton:', e);\n            }\n        };\n        const processHandlers = () => {\n            if (handlers.length > 0) {\n                let selectedHandler = {\n                    priority: Number.MIN_SAFE_INTEGER,\n                    handler: () => undefined,\n                    id: -1,\n                };\n                handlers.forEach((handler) => {\n                    if (handler.priority >= selectedHandler.priority) {\n                        selectedHandler = handler;\n                    }\n                });\n                busy = true;\n                handlers = handlers.filter((handler) => handler.id !== selectedHandler.id);\n                executeAction(selectedHandler).then(() => (busy = false));\n            }\n        };\n        processHandlers();\n    };\n    /**\n     * If the CloseWatcher is defined then\n     * we don't want to also listen for the native\n     * backbutton event otherwise we may get duplicate\n     * events firing.\n     */\n    if (shouldUseCloseWatcher()) {\n        let watcher;\n        const configureWatcher = () => {\n            watcher === null || watcher === void 0 ? void 0 : watcher.destroy();\n            watcher = new win.CloseWatcher();\n            /**\n             * Once a close request happens\n             * the watcher gets destroyed.\n             * As a result, we need to re-configure\n             * the watcher so we can respond to other\n             * close requests.\n             */\n            watcher.onclose = () => {\n                backButtonCallback();\n                configureWatcher();\n            };\n        };\n        configureWatcher();\n    }\n    else {\n        doc.addEventListener('backbutton', backButtonCallback);\n    }\n};\nconst OVERLAY_BACK_BUTTON_PRIORITY = 100;\nconst MENU_BACK_BUTTON_PRIORITY = 99; // 1 less than overlay priority since menu is displayed behind overlays\n\nexport { MENU_BACK_BUTTON_PRIORITY, OVERLAY_BACK_BUTTON_PRIORITY, blockHardwareBackButton, shouldUseCloseWatcher, startHardwareBackButton };\n"],"mappings":";;;;;;;;;;;;;;;AAAA,IAkBM,uBAWA,yBAGA,yBA+EA,8BACA;AAhHN;AAAA;AAGA;AACA;AAcA,IAAM,wBAAwB,MAAM,OAAO,IAAI,4BAA4B,KAAK,KAAK,QAAQ,UAAa,kBAAkB;AAW5H,IAAM,0BAA0B,MAAM;AAClC,eAAS,iBAAiB,cAAc,MAAM;AAAA,MAAE,CAAC;AAAA,IACrD;AACA,IAAM,0BAA0B,MAAM;AAClC,YAAM,MAAM;AACZ,UAAI,OAAO;AACX,YAAM,qBAAqB,MAAM;AAC7B,YAAI,MAAM;AACN;AAAA,QACJ;AACA,YAAI,QAAQ;AACZ,YAAI,WAAW,CAAC;AAChB,cAAM,KAAK,IAAI,YAAY,iBAAiB;AAAA,UACxC,SAAS;AAAA,UACT,QAAQ;AAAA,YACJ,SAAS,UAAU,SAAS;AACxB,uBAAS,KAAK,EAAE,UAAU,SAAS,IAAI,QAAQ,CAAC;AAAA,YACpD;AAAA,UACJ;AAAA,QACJ,CAAC;AACD,YAAI,cAAc,EAAE;AACpB,cAAM,gBAAgB,CAAO,oBAAoB;AAC7C,cAAI;AACA,gBAAI,oBAAoB,QAAQ,oBAAoB,SAAS,SAAS,gBAAgB,SAAS;AAC3F,oBAAM,SAAS,gBAAgB,QAAQ,eAAe;AACtD,kBAAI,UAAU,MAAM;AAChB,sBAAM;AAAA,cACV;AAAA,YACJ;AAAA,UACJ,SACO,GAAG;AACN,0BAAc,qDAAqD,CAAC;AAAA,UACxE;AAAA,QACJ;AACA,cAAM,kBAAkB,MAAM;AAC1B,cAAI,SAAS,SAAS,GAAG;AACrB,gBAAI,kBAAkB;AAAA,cAClB,UAAU,OAAO;AAAA,cACjB,SAAS,MAAM;AAAA,cACf,IAAI;AAAA,YACR;AACA,qBAAS,QAAQ,CAAC,YAAY;AAC1B,kBAAI,QAAQ,YAAY,gBAAgB,UAAU;AAC9C,kCAAkB;AAAA,cACtB;AAAA,YACJ,CAAC;AACD,mBAAO;AACP,uBAAW,SAAS,OAAO,CAAC,YAAY,QAAQ,OAAO,gBAAgB,EAAE;AACzE,0BAAc,eAAe,EAAE,KAAK,MAAO,OAAO,KAAM;AAAA,UAC5D;AAAA,QACJ;AACA,wBAAgB;AAAA,MACpB;AAOA,UAAI,sBAAsB,GAAG;AACzB,YAAI;AACJ,cAAM,mBAAmB,MAAM;AAC3B,sBAAY,QAAQ,YAAY,SAAS,SAAS,QAAQ,QAAQ;AAClE,oBAAU,IAAI,IAAI,aAAa;AAQ/B,kBAAQ,UAAU,MAAM;AACpB,+BAAmB;AACnB,6BAAiB;AAAA,UACrB;AAAA,QACJ;AACA,yBAAiB;AAAA,MACrB,OACK;AACD,YAAI,iBAAiB,cAAc,kBAAkB;AAAA,MACzD;AAAA,IACJ;AACA,IAAM,+BAA+B;AACrC,IAAM,4BAA4B;AAAA;AAAA;","names":[],"x_google_ignoreList":[0]}